<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>AI Etch A Sketch - Draw with AI</title>
<style>
  :root { --bg: #0f172a; --panel: rgba(255,255,255,.9); --text:#0f172a; }
  html, body { height: 100%; }
  body {
    margin: 0;
    background: var(--bg);
    font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, "Helvetica Neue", Arial, "Noto Sans", "Apple Color Emoji", "Segoe UI Emoji";
  }
  #canvas { position: fixed; inset: 0; display:block; }
  .toolbar {
    position: fixed; top: 12px; left: 12px; z-index: 10;
    display: flex; gap: 10px; align-items: center; flex-wrap: wrap;
    background: var(--panel); color: var(--text);
    padding: 10px 12px; border-radius: 14px; box-shadow: 0 10px 30px rgba(0,0,0,.25);
    backdrop-filter: saturate(140%) blur(6px);
  }
  .toolbar label { font-size: 12px; opacity: .8; margin-right: 6px; }
  .toolbar input[type="range"] { width: 140px; }
  .btn {
    appearance: none; border: 0; border-radius: 10px; padding: 8px 12px; cursor: pointer;
    background: #111827; color: #fff; font-weight: 600; font-size: 13px; letter-spacing:.2px;
  }
  .btn.ghost { background: transparent; color: #111827; border:1px solid #11182733; }
  .btn.link { background: #3b82f6; color: #fff; text-decoration: none; display: inline-flex; align-items: center; gap: 6px; }
  .btn[aria-pressed="true"]{ outline: 2px solid #111827; outline-offset:2px; }
  .swatch { width: 36px; height: 36px; border-radius: 10px; border: 1px solid #0001; overflow: hidden; display:inline-grid; place-items:center; }
  .swatch input[type="color"]{ appearance: none; width: 100%; height: 100%; border:0; padding:0; background: none; cursor: pointer; }
  .sizePreview{ width: 36px; height: 36px; display:grid; place-items:center; }
  .dot{ border-radius: 999px; background: #111827; width: var(--size, 6px); height: var(--size, 6px); }
  .hint { position: fixed; bottom: 12px; left: 12px; color: #fff8; font-size: 12px; max-width: 600px; }

  /* Modal */
  .modal-overlay{ position: fixed; inset:0; background: rgba(0,0,0,.5); display:none; align-items:center; justify-content:center; z-index: 20; }
  .modal{ background: #fff; color:#0f172a; width: min(720px, 92vw); border-radius: 16px; box-shadow: 0 20px 60px rgba(0,0,0,.35); overflow:hidden; }
  .modal header{ padding:14px 16px; font-weight:700; background:#f1f5f9; display:flex; align-items:center; justify-content:space-between; }
  .modal .body{ padding:16px; display:grid; gap:12px; }
  .modal footer{ padding:12px 16px; display:flex; gap:10px; justify-content:flex-end; background:#f8fafc; }
  .modal textarea{ width:100%; min-height:120px; resize:vertical; font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; padding: 8px; border-radius: 10px; border: 1px solid #cbd5e1; }
  .modal input[type="password"], .modal input[type="text"]{ width:100%; padding:8px; border-radius:10px; border:1px solid #cbd5e1; font-family:inherit; }
  .modal select{ width:100%; padding:8px; border-radius:10px; border:1px solid #cbd5e1; font-family:inherit; background: #fff; }
  .row{ display:grid; grid-template-columns: 1fr 1fr; gap:12px; }
  .help{ font-size:12px; color:#475569; margin-top: 4px; }
  .api-choice{ display: flex; gap: 8px; align-items: center; }
  .api-choice input[type="radio"]{ margin: 0; }
</style>
</head>
<body>

  <canvas id="canvas"></canvas>

  <div class="toolbar" role="toolbar" aria-label="Paint controls">
    <div class="swatch" title="Brush color">
      <input id="color" type="color" value="#c0392b" aria-label="Brush color" />
    </div>

    <label for="bgColor">BG</label>
    <div class="swatch" title="Background color">
      <input id="bgColor" type="color" value="#0f172a" aria-label="Background color" />
    </div>

    <div class="sizePreview" title="Brush size preview"><div id="sizeDot" class="dot"></div></div>

    <label for="size">Size</label>
    <input id="size" type="range" min="1" max="60" value="5" step="1" aria-label="Brush size" />

    <button id="eraser" class="btn ghost" aria-pressed="false" title="Eraser (toggle)">Eraser</button>
    <button id="clear" class="btn ghost" title="Clear canvas">Clear</button>
    <button id="save" class="btn" title="Download PNG">Save</button>

    <!-- Recording controls -->
    <button id="record" class="btn" aria-pressed="false" title="Record strokes">‚è∫ Record</button>
    <button id="downloadRec" class="btn ghost" title="Export recording JSON">Export</button>
    <input id="loadInput" type="file" accept="application/json" hidden />
    <button id="loadBtn" class="btn ghost" title="Import recording JSON">Import</button>
    <button id="play" class="btn" title="Play recording">Play</button>
    <button id="stop" class="btn ghost" title="Stop playback">Stop</button>

    <!-- AI Assist -->
    <button id="aiAssist" class="btn" title="AI Etch A Sketch">üé® AI Draw</button>

    <span id="status" style="font-size:12px; opacity:.7; margin-left:6px;"></span>
  </div>

  <!-- AI Assist Modal -->
  <div id="aiModal" class="modal-overlay" role="dialog" aria-modal="true" aria-labelledby="aiTitle">
    <div class="modal">
      <header>
        <div id="aiTitle">üé® AI Etch A Sketch - Describe what to draw</div>
        <button id="aiClose" class="btn ghost" aria-label="Close">‚úï</button>
      </header>
      <div class="body">
        <div>
          <label for="aiPrompt">Drawing Prompt</label>
          <textarea id="aiPrompt" placeholder="e.g., Draw a simple house with a chimney, windows, door, and a tree next to it"></textarea>
          <div class="help">Describe your drawing in detail. The AI will create it stroke-by-stroke!</div>
        </div>

        <div>
          <label for="skillLevel">Drawing Skill Level</label>
          <select id="skillLevel">
            <option value="child">üë∂ Child (5-year-old style) - Simple stick figures</option>
            <option value="intermediate" selected>üë® Intermediate - Cleaner lines, recognizable shapes</option>
            <option value="professional">üé® Professional - Detailed artistic sketches</option>
          </select>
          <div class="help">Choose the drawing complexity: from simple child-like doodles to professional sketches.</div>
        </div>

        <div>
          <label>AI Provider</label>
          <div class="api-choice">
            <input type="radio" id="useClaude" name="apiProvider" value="claude" checked />
            <label for="useClaude" style="margin: 0;">Claude (Recommended - Best for drawing)</label>
          </div>
          <div class="api-choice" style="margin-top: 6px;">
            <input type="radio" id="useOpenAI" name="apiProvider" value="openai" />
            <label for="useOpenAI" style="margin: 0;">OpenAI (Fallback)</label>
          </div>
        </div>

        <div id="claudeApiSection">
          <label for="claudeKey">Claude API Key</label>
          <div style="display: flex; gap: 8px;">
            <input id="claudeKey" type="password" placeholder="Enter your Claude API key" style="flex: 1;" />
            <a href="https://console.anthropic.com/settings/keys" target="_blank" class="btn link" title="Get Claude API Key">
              üîë Get Key
            </a>
          </div>
          <div class="help">Get your free Claude API key by clicking the button above. Copy and paste it here. Stored locally in your browser.</div>
        </div>

        <div id="openaiApiSection" style="display: none;">
          <label for="openaiKey">OpenAI API Key</label>
          <div style="display: flex; gap: 8px;">
            <input id="openaiKey" type="password" placeholder="Enter your OpenAI API key" style="flex: 1;" />
            <a href="https://platform.openai.com/api-keys" target="_blank" class="btn link" title="Get OpenAI API Key">
              üîë Get Key
            </a>
          </div>
          <div class="help">Get your OpenAI API key by clicking the button above. Copy and paste it here.</div>
        </div>

        <div id="aiError" class="help" style="color:#b91c1c; display:none;"></div>
      </div>
      <footer>
        <button id="aiCancel" class="btn ghost">Cancel</button>
        <button id="aiRun" class="btn">üé® Generate & Play</button>
      </footer>
    </div>
  </div>

  <div class="hint">
    <strong>üé® AI Etch A Sketch</strong> - Draw with your mouse/touch or let AI create drawings for you!<br>
    Click "AI Draw" to describe what you want to draw. Choose skill level from simple child-like to professional sketches.
  </div>

<script>
(function(){
  const canvas = document.getElementById('canvas');
  const ctx = canvas.getContext('2d');

  // UI elements
  const colorInput = document.getElementById('color');
  const bgInput    = document.getElementById('bgColor');
  const sizeInput  = document.getElementById('size');
  const clearBtn   = document.getElementById('clear');
  const saveBtn    = document.getElementById('save');
  const eraserBtn  = document.getElementById('eraser');
  const sizeDot    = document.getElementById('sizeDot');

  // Recording & playback controls
  const recordBtn   = document.getElementById('record');
  const downloadRec = document.getElementById('downloadRec');
  const loadBtn     = document.getElementById('loadBtn');
  const loadInput   = document.getElementById('loadInput');
  const playBtn     = document.getElementById('play');
  const stopBtn     = document.getElementById('stop');
  const statusEl    = document.getElementById('status');

  // AI Assist elements
  const aiAssistBtn = document.getElementById('aiAssist');
  const aiModal  = document.getElementById('aiModal');
  const aiClose  = document.getElementById('aiClose');
  const aiCancel = document.getElementById('aiCancel');
  const aiRun    = document.getElementById('aiRun');
  const aiPrompt = document.getElementById('aiPrompt');
  const skillLevel = document.getElementById('skillLevel');
  const claudeKey = document.getElementById('claudeKey');
  const openaiKey = document.getElementById('openaiKey');
  const useClaude = document.getElementById('useClaude');
  const useOpenAI = document.getElementById('useOpenAI');
  const claudeApiSection = document.getElementById('claudeApiSection');
  const openaiApiSection = document.getElementById('openaiApiSection');
  const aiError  = document.getElementById('aiError');

  // State
  let drawing = false;
  let lastX = 0, lastY = 0;
  let brushColor = colorInput.value;
  let brushSize = parseInt(sizeInput.value, 10);
  let erasing = false;
  // Background color state (CSS var --bg)
  let bgColor = (getComputedStyle(document.documentElement).getPropertyValue('--bg') || '#0f172a').trim();

  // Recording state
  let isRecording = false;
  let recording = { version: 1, canvas: { w: 0, h: 0 }, strokes: [] };
  let currentStroke = null;
  // Playback state
  let loadedRecording = null; // when importing, store here
  let stopPlaybackFlag = false;

  function setStatus(msg){ statusEl.textContent = msg || ''; }
  function showModal(){ 
    aiModal.style.display = 'flex'; 
    aiError.style.display = 'none'; 
    aiError.textContent=''; 
    // Load saved keys from localStorage
    const savedClaudeKey = localStorage.getItem('claudeApiKey');
    const savedOpenAIKey = localStorage.getItem('openaiApiKey');
    if (savedClaudeKey) claudeKey.value = savedClaudeKey;
    if (savedOpenAIKey) openaiKey.value = savedOpenAIKey;
    aiPrompt.focus(); 
  }
  function hideModal(){ aiModal.style.display = 'none'; }
  function showAlert(msg){ aiError.textContent = msg; aiError.style.display = 'block'; }

  // Toggle API provider sections
  function toggleApiSections() {
    if (useClaude.checked) {
      claudeApiSection.style.display = 'block';
      openaiApiSection.style.display = 'none';
    } else {
      claudeApiSection.style.display = 'none';
      openaiApiSection.style.display = 'block';
    }
  }
  useClaude.addEventListener('change', toggleApiSections);
  useOpenAI.addEventListener('change', toggleApiSections);

  // Improve sharpness on HiDPI
  function resizeCanvas() {
    const dpr = window.devicePixelRatio || 1;
    const w = window.innerWidth;
    const h = window.innerHeight;
    // Save current content
    const tmp = document.createElement('canvas');
    tmp.width = canvas.width; tmp.height = canvas.height;
    const tctx = tmp.getContext('2d');
    tctx.drawImage(canvas, 0, 0);

    canvas.width = Math.floor(w * dpr);
    canvas.height = Math.floor(h * dpr);
    canvas.style.width = w + 'px';
    canvas.style.height = h + 'px';
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0); // scale drawing ops
    // Restore content (scaled)
    ctx.drawImage(tmp, 0, 0, tmp.width / dpr, tmp.height / dpr);
    tmp.width = tmp.height = 0; // GC hint
  }

  function setStyle() {
    ctx.lineWidth = brushSize;
    ctx.lineCap = 'round';
    ctx.lineJoin = 'round';
    ctx.strokeStyle = brushColor;
    ctx.globalCompositeOperation = erasing ? 'destination-out' : 'source-over';
    sizeDot.style.setProperty('--size', Math.max(4, brushSize) + 'px');
    sizeDot.style.background = erasing ? '#000' : brushColor;
  }

  function startDraw(x, y){
    drawing = true;
    [lastX, lastY] = [x, y];
    setStyle();

    if (isRecording){
      currentStroke = {
        color: brushColor,
        size: brushSize,
        erasing,
        points: [],
        t0: performance.now()
      };
      currentStroke.points.push({ x, y, t: 0 });
    }
  }

  function drawLine(x, y){
    if (!drawing) return;
    ctx.beginPath();
    ctx.moveTo(lastX, lastY);
    ctx.lineTo(x, y);
    ctx.stroke();

    if (isRecording && currentStroke){
      currentStroke.points.push({ x, y, t: performance.now() - currentStroke.t0 });
    }

    [lastX, lastY] = [x, y];
  }

  function endDraw(){
    if (!drawing) return;
    drawing = false;
    if (isRecording && currentStroke){
      recording.strokes.push({
        color: currentStroke.color,
        size: currentStroke.size,
        erasing: currentStroke.erasing,
        points: currentStroke.points
      });
      currentStroke = null;
      setStatus(`Recorded strokes: ${recording.strokes.length}`);
    }
  }

  // Mouse events
  canvas.addEventListener('mousedown', (e)=> startDraw(e.clientX, e.clientY));
  canvas.addEventListener('mousemove', (e)=> drawLine(e.clientX, e.clientY));
  ['mouseup','mouseleave'].forEach(ev=> canvas.addEventListener(ev, endDraw));

  // Touch events
  canvas.addEventListener('touchstart', (e)=>{
    if (e.touches.length > 0){
      const t = e.touches[0];
      startDraw(t.clientX, t.clientY);
    }
  }, {passive:true});
  canvas.addEventListener('touchmove', (e)=>{
    if (e.touches.length > 0){
      const t = e.touches[0];
      drawLine(t.clientX, t.clientY);
      e.preventDefault(); // prevent page scroll while drawing
    }
  }, {passive:false});
  canvas.addEventListener('touchend', endDraw);
  canvas.addEventListener('touchcancel', endDraw);

  // Controls
  colorInput.addEventListener('input', (e)=>{ brushColor = e.target.value; setStyle(); });
  bgInput.addEventListener('input', (e)=>{
    bgColor = e.target.value;
    // Update CSS variable so the page background updates immediately
    document.documentElement.style.setProperty('--bg', bgColor);
  });
  sizeInput.addEventListener('input', (e)=>{ brushSize = parseInt(e.target.value,10); setStyle(); });
  eraserBtn.addEventListener('click', ()=>{
    erasing = !erasing;
    eraserBtn.setAttribute('aria-pressed', String(erasing));
    setStyle();
  });
  clearBtn.addEventListener('click', ()=>{
    const {width, height} = canvas;
    ctx.clearRect(0, 0, width, height);
  });
  saveBtn.addEventListener('click', ()=>{
    // Export a flattened PNG with the selected background color without mutating the main canvas
    const tmp = document.createElement('canvas');
    tmp.width = canvas.width; tmp.height = canvas.height;
    const tctx = tmp.getContext('2d');
    // Fill background
    tctx.fillStyle = bgColor || '#ffffff';
    tctx.fillRect(0, 0, tmp.width, tmp.height);
    // Draw current canvas on top
    tctx.drawImage(canvas, 0, 0);

    const link = document.createElement('a');
    link.download = 'ai-etch-sketch.png';
    link.href = tmp.toDataURL('image/png');
    link.click();
  });

  // === Recording & Playback ===
  recordBtn.addEventListener('click', ()=>{
    isRecording = !isRecording;
    if (isRecording){
      recording = { version: 1, canvas: { w: window.innerWidth, h: window.innerHeight }, strokes: [] };
      setStatus('Recording‚è∫');
    } else {
      setStatus(`Recording stopped. Strokes: ${recording.strokes.length}`);
    }
    recordBtn.setAttribute('aria-pressed', String(isRecording));
    recordBtn.textContent = isRecording ? '‚èπ Stop' : '‚è∫ Record';
  });

  downloadRec.addEventListener('click', ()=>{
    const data = JSON.stringify(recording, null, 2);
    const blob = new Blob([data], { type: 'application/json' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = 'etch-sketch-strokes.json';
    a.click();
    URL.revokeObjectURL(url);
  });

  loadBtn.addEventListener('click', ()=> loadInput.click());
  loadInput.addEventListener('change', (e)=>{
    const file = e.target.files && e.target.files[0];
    if (!file) return;
    const reader = new FileReader();
    reader.onload = ()=>{
      try{
        const obj = JSON.parse(String(reader.result));
        if (!obj || !Array.isArray(obj.strokes)) throw new Error('Invalid format');
        loadedRecording = obj;
        setStatus(`Loaded recording with ${obj.strokes.length} stroke(s).`);
      }catch(err){
        setStatus('Failed to load: ' + err.message);
      }
    };
    reader.readAsText(file);
    // reset input so same file can be chosen again
    e.target.value = '';
  });

  function sleep(ms){ return new Promise(r=> setTimeout(r, ms)); }

  async function playRecording(rec){
    if (!rec || !Array.isArray(rec.strokes) || rec.strokes.length === 0){
      setStatus('Nothing to play.');
      return;
    }
    // Clear canvas before playback
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    stopPlaybackFlag = false;
    setStatus('Playing‚ñ∂');

    for (const s of rec.strokes){
      if (stopPlaybackFlag) break;
      // Apply style for this stroke
      const prevColor = brushColor, prevSize = brushSize, prevErase = erasing;
      brushColor = s.color; brushSize = s.size; erasing = !!s.erasing; setStyle();

      // Draw the stroke respecting timing between points
      const pts = s.points || [];
      if (pts.length < 2) { continue; }

      // Move to first point
      let [x0, y0, t0] = [pts[0].x, pts[0].y, pts[0].t || 0];
      for (let i = 1; i < pts.length; i++){
        if (stopPlaybackFlag) break;
        const p = pts[i];
        const wait = Math.max(0, (p.t || 0) - (pts[i-1].t || 0));
        if (wait) await sleep(wait);
        ctx.beginPath();
        ctx.moveTo(x0, y0);
        ctx.lineTo(p.x, p.y);
        ctx.stroke();
        x0 = p.x; y0 = p.y; t0 = p.t || 0;
      }

      // restore user-selected style after each stroke
      brushColor = prevColor; brushSize = prevSize; erasing = prevErase; setStyle();
    }

    setStatus(stopPlaybackFlag ? 'Playback stopped.' : 'Playback finished.');
  }

  playBtn.addEventListener('click', ()=>{
    const rec = loadedRecording && loadedRecording.strokes?.length ? loadedRecording : recording;
    playRecording(rec);
  });
  stopBtn.addEventListener('click', ()=>{ stopPlaybackFlag = true; });

  // === AI Assist with Etch A Sketch Style ===
  aiAssistBtn.addEventListener('click', showModal);
  aiClose.addEventListener('click', hideModal);
  aiCancel.addEventListener('click', hideModal);
  aiModal.addEventListener('click', (e)=>{ if(e.target === aiModal) hideModal(); });

  async function generateWithClaude(prompt, skill, key) {
    const canvasW = Math.round(canvas.width / (window.devicePixelRatio||1));
    const canvasH = Math.round(canvas.height / (window.devicePixelRatio||1));

    const skillConfigs = {
      child: {
        strokes: '5-15',
        style: 'very simple stick figures, basic circles and lines, wobbly hand movements like a 5-year-old',
        size: '8-15',
        complexity: 'minimal detail'
      },
      intermediate: {
        strokes: '15-30',
        style: 'cleaner lines, recognizable shapes, more controlled strokes',
        size: '5-10',
        complexity: 'moderate detail'
      },
      professional: {
        strokes: '30-60',
        style: 'smooth continuous lines, artistic shading with line density, professional technique',
        size: '2-8',
        complexity: 'high detail, artistic perspective'
      }
    };

    const config = skillConfigs[skill] || skillConfigs.intermediate;

    const systemPrompt = `You are an Etch A Sketch drawing assistant. Generate drawings as continuous, flowing strokes.

CRITICAL: Return ONLY valid JSON. No markdown, no explanation, no backticks.

JSON Schema:
{
  "version": 1,
  "canvas": { "w": ${canvasW}, "h": ${canvasH} },
  "strokes": [
    {
      "color": "hex color string",
      "size": number,
      "erasing": false,
      "points": [{ "x": number, "y": number, "t": number }]
      }
  ]
}

Skill Level: ${skill}
- Stroke count: ${config.strokes}
- Line size: ${config.size}
- Style: ${config.style}
- Complexity: ${config.complexity}

Rules:
- Each stroke should have 3-50 points for smooth curves
- t values increase gradually (0, 10, 20, 30... milliseconds)
- Coordinates within bounds: x: 0-${canvasW}, y: 0-${canvasH}
- Create continuous, flowing Etch A Sketch style strokes
- Use appropriate colors and line weights for the skill level`;

    const userPrompt = `Draw: ${prompt}

Canvas: ${canvasW}x${canvasH}
Skill: ${skill}

Create an Etch A Sketch style drawing with ${config.strokes} strokes.
Return ONLY the JSON object.`;

    const response = await fetch('https://api.anthropic.com/v1/messages', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'x-api-key': key,
        'anthropic-version': '2023-06-01'
      },
      body: JSON.stringify({
        model: 'claude-sonnet-4-5-20250929',
        max_tokens: 4096,
        temperature: 0.3,
        system: systemPrompt,
        messages: [
          { role: 'user', content: userPrompt }
        ]
      })
    });

    if (!response.ok) {
      const errorText = await response.text().catch(() => '');
      throw new Error(`Claude API error ${response.status}: ${errorText.slice(0, 200)}`);
    }

    const data = await response.json();
    const content = data.content[0].text;
    return content;
  }

  async function generateWithOpenAI(prompt, skill, key) {
    const canvasW = Math.round(canvas.width / (window.devicePixelRatio||1));
    const canvasH = Math.round(canvas.height / (window.devicePixelRatio||1));

    const skillConfigs = {
      child: { strokes: '5-15', style: 'simple stick figures, wobbly lines', size: '8-15' },
      intermediate: { strokes: '15-30', style: 'cleaner lines, recognizable shapes', size: '5-10' },
      professional: { strokes: '30-60', style: 'smooth artistic lines, detailed', size: '2-8' }
    };

    const config = skillConfigs[skill] || skillConfigs.intermediate;

    const systemPrompt = `You generate Etch A Sketch style drawing recordings.
Return ONLY valid JSON (no prose, no backticks).
Schema: {
  version: 1,
  canvas: { w: number, h: number },
  strokes: Array<{ color: string, size: number, erasing: boolean, points: Array<{ x: number, y: number, t: number }> }>
}.
Skill: ${skill}. Strokes: ${config.strokes}. Style: ${config.style}. Line size: ${config.size}.
Create continuous, flowing strokes. Each stroke 3-50 points. t increases (0,10,20...). Coords: 0-${canvasW}, 0-${canvasH}.`;

    const userPrompt = `Canvas: ${canvasW}x${canvasH}. Draw: ${prompt}. Return ONLY JSON.`;

    const response = await fetch('https://api.openai.com/v1/chat/completions', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${key}`
      },
      body: JSON.stringify({
        model: 'gpt-4o-mini',
        temperature: 0.2,
        messages: [
          { role: 'system', content: systemPrompt },
          { role: 'user', content: userPrompt }
        ]
      })
    });

    if (!response.ok) {
      const errorText = await response.text().catch(() => '');
      throw new Error(`OpenAI API error ${response.status}: ${errorText.slice(0, 200)}`);
    }

    const data = await response.json();
    return data.choices[0].message.content;
  }

  function parseDrawingJSON(text) {
    try {
      return JSON.parse(text);
    } catch (e) {
      const jsonMatch = text.match(/\{[\s\S]*\}/);
      if (jsonMatch) {
        try {
          return JSON.parse(jsonMatch[0]);
        } catch (innerError) {
          throw new Error('Could not parse JSON from AI response');
        }
      }
      throw new Error('No valid JSON found in response');
    }
  }

  aiRun.addEventListener('click', async ()=>{
    try{
      aiError.style.display = 'none'; 
      aiError.textContent='';
      
      const prompt = aiPrompt.value.trim();
      if(!prompt){ 
        showAlert('Please enter a drawing prompt.'); 
        return; 
      }

      const skill = skillLevel.value;
      const provider = useClaude.checked ? 'claude' : 'openai';
      
      let key, text;
      
      if (provider === 'claude') {
        key = claudeKey.value.trim();
        if (!key) {
          showAlert('Please enter your Claude API key. Click "Get Key" to get one from Anthropic.');
          return;
        }
        // Save key to localStorage
        localStorage.setItem('claudeApiKey', key);
        
        setStatus('Contacting Claude AI...');
        text = await generateWithClaude(prompt, skill, key);
      } else {
        key = openaiKey.value.trim();
        if (!key) {
          showAlert('Please enter your OpenAI API key. Click "Get Key" to get one from OpenAI.');
          return;
        }
        // Save key to localStorage
        localStorage.setItem('openaiApiKey', key);
        
        setStatus('Contacting OpenAI...');
        text = await generateWithOpenAI(prompt, skill, key);
      }

      const obj = parseDrawingJSON(text);
      
      if(!obj || !Array.isArray(obj.strokes)){
        showAlert('The model did not return valid JSON. Showing raw response below.');
        aiError.textContent = (aiError.textContent + "\n\n" + text).slice(0,4000);
        aiError.style.whiteSpace = 'pre-wrap';
        setStatus('AI returned non-JSON.');
        return;
      }
      
      loadedRecording = obj;
      hideModal();
      setStatus(`AI generated ${obj.strokes.length} strokes (${skill} level). Playing...`);
      await playRecording(obj);
      
    }catch(err){
      showAlert(String(err.message || err));
      setStatus('AI generation error.');
    }
  });

  // init
  window.addEventListener('resize', resizeCanvas);
  resizeCanvas();
  setStyle();
})();
</script>
</body>
</html>
